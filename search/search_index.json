{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hello \u00b6","title":"Home"},{"location":"#hello","text":"","title":"Hello"},{"location":"kubernetes/tipsandtricks/","text":"Get list of pods and nodes \u00b6 1. Find all problem pods which not in Running state kubectl get pods -A --field-selector = status.phase! = Running | grep -v Complete Output ingress traefik-ingress-controller-77b6cbdf77-m724s 0/2 Evicted 0 42d ingress traefik-ingress-controller-77b6cbdf77-scsh5 0/2 Evicted 0 60d ingress traefik-ingress-controller-77b6cbdf77-vn5c9 0/2 Evicted 0 79d testing administration-v1-app-dd8699bb-znq6m 0/1 ImagePullBackOff 0 117m testing administration-v1-app-ffff66c9c-gs8pw 0/1 ImagePullBackOff 0 99m testing administration-v1-app-ffff66c9c-ngwjm 0/1 ImagePullBackOff 0 99m 2. Get list of nodes with ram capacity: kubectl get no -o json | \\ jq -r '.items | sort_by(.status.capacity.memory)[]|[.metadata.name,.status.capacity.memory]| @tsv' Output k8s-worker-system-01-dc14-fsn1 32171364Ki k8s-worker-system-01-dc3-nbg1 32171364Ki k8s-worker-system-02-dc14-fsn1 32171368Ki k8s-worker-system-02-dc3-nbg1 32171368Ki k8s-master-system-01-dc14-fsn1 7979256Ki k8s-master-system-01-dc3-nbg1 7979256Ki k8s-master-system-02-dc3-nbg1 7979264Ki 3. Get list of nodes with running pods on it: kubectl get po -o json --all-namespaces | \\ jq '.items | group_by(.spec.nodeName) | map({\"nodeName\": .[0].spec.nodeName, \"count\": length}) | sort_by(.count)' Output [ { \"nodeName\" : \"k8s-master-system-01-dc14-fsn1\" , \"count\" : 7 }, { \"nodeName\" : \"k8s-master-system-01-dc3-nbg1\" , \"count\" : 7 }, { \"nodeName\" : \"k8s-master-system-02-dc3-nbg1\" , \"count\" : 7 }, { \"nodeName\" : \"k8s-worker-system-01-dc3-nbg1\" , \"count\" : 14 }, { \"nodeName\" : \"k8s-worker-system-01-dc14-fsn1\" , \"count\" : 18 }, { \"nodeName\" : \"k8s-worker-system-02-dc14-fsn1\" , \"count\" : 18 }, { \"nodeName\" : \"k8s-worker-system-02-dc3-nbg1\" , \"count\" : 22 } ] 3. Script for list nodes which can not rollout DaemonSet ns = my-namespace pod_template = my-pod kubectl get node | grep -v \\\" $( kubectl -n ${ ns } get pod --all-namespaces -o wide | fgrep ${ pod_template } | awk '{print $8}' | xargs -n 1 echo -n \"\\|\" | sed 's/[[:space:]]*//g' ) \\\" 4. Get pod's that consume the maximum amount of cpu or memory: # cpu kubectl top pods -A | sort --reverse --key 3 --numeric # memory kubectl top pods -A | sort --reverse --key 4 --numeric Get other information \u00b6 1. Debugging Ingress with wide output and finding labels: kubectl -n jaeger get svc -o wide Output NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTOR jaeger-cassandra ClusterIP None <none> 9042/TCP 77d app=cassandracluster,cassandracluster=jaeger-cassandra,cluster=jaeger-cassandra In this case, we immediately get a selector by which it finds the necessary pods. 2. Get limits and requests for each container of each pod: kubectl get pods -n my-namespace -o = custom-columns = 'NAME:spec.containers[*].name,MEMREQ:spec.containers[*].resources.requests.memory,MEMLIM:spec.containers[*].resources.limits.memory,CPUREQ:spec.containers[*].resources.requests.cpu,CPULIM:spec.containers[*].resources.limits.cpu' Output NAME MEMREQ MEMLIM CPUREQ CPULIM sentry-web 2Gi 2Gi 300m 700m sentry-web 2Gi 2Gi 300m 700m sentry-web 2Gi 2Gi 300m 700m sentry-web 2Gi 2Gi 300m 700m sentry-worker 1Gi 3Gi 300m 1 sentry-worker 1Gi 3Gi 300m 1 sentry-worker 1Gi 3Gi 300m 1 sentry-worker 1Gi 3Gi 300m 1 sentry-worker 1Gi 3Gi 300m 1 3. The kubectl run command (as well as create, apply, patch) has a wonderful ability to see changes before applying them - the --dry-run flag does this. And if used in conjunction with -o yaml , you can get the manifest of the required entity. For example: kubectl run test --image = grafana/grafana --dry-run -o yaml Output apiVersion : apps/v1 kind : Deployment metadata : creationTimestamp : null labels : run : test name : test spec : replicas : 1 selector : matchLabels : run : test strategy : {} template : metadata : creationTimestamp : null labels : run : test spec : containers : - image : grafana/grafana name : test resources : {} status : {} 4. Get an explanation on the manifest of a resource: kubectl explain hpa Output KIND: HorizontalPodAutoscaler VERSION: autoscaling/v1 DESCRIPTION: configuration of a horizontal pod autoscaler. FIELDS: apiVersion <string> APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources kind <string> Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds metadata <Object> Standard object metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata spec <Object> behaviour of autoscaler. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status. status <Object> current information about the autoscaler. Networks \u00b6 1. Get internal IP addresses of cluster nodes: kubectl get nodes -o json | \\ jq -r '.items[].status.addresses[]? | select (.type == \"InternalIP\") | .address' | \\ paste -sd \"\\n\" - Output 49.12.46.61 159.69.86.119 159.69.30.239 168.119.52.4 159.69.158.121 168.119.50.31 116.203.153.163 2. List all services and the nodePort they occupy: kubectl get --all-namespaces svc -o json | \\ jq -r '.items[] | [.metadata.name,([.spec.ports[].nodePort | tostring ] | join(\"|\"))]| @tsv' Output nginx-ingress-controller 32244|32245 3 . In situations where there are problems with CNI, routes must be checked to identify the problem pod. This is where the pod subnets used in the cluster come in very handy: kubectl get nodes -o jsonpath = '{.items[*].spec.podCIDR}' | tr \" \" \"\\n\" Output 192.168.0.0/24 192.168.1.0/24 192.168.2.0/24 192.168.4.0/24 192.168.3.0/24 192.168.6.0/24 192.168.5.0/24 Logs \u00b6 1. Getting pod logs with human readable timestamp in case of its absence kubectl -n my-namespace logs -f my-pod --timestamps Output 2020-07-08T14:01:59.581788788Z fail: Microsoft.EntityFrameworkCore.Query[10100] 2. Don't wait for the entire pod container log to be displayed - use --tail : kubectl -n my-namespace logs -f my-pod --tail = 50 3. Get logs from all pod containers: kubectl -n my-namespace logs -f my-pod --all-containers 4. Get logs from all pods based on the label: kubectl -n my-namespace logs -f -l app = nginx 5. Get the logs of the previous container, which, for example, fell: kubectl -n my-namespace logs my-pod --previous List All Container Images Running in a Cluster \u00b6 1. List all Container images in all namespaces kubectl get pods --all-namespaces -o jsonpath = \"{..image}\" | \\ tr -s '[[:space:]]' '\\n' | \\ sort | \\ uniq -c kubectl get pods --all-namespaces -o jsonpath = \"{.items[*].spec.containers[*].image}\" 2. List Container images by Pod kubectl get pods --all-namespaces -o = jsonpath = '{range .items[*]}{\"\\n\"}{.metadata.name}{\":\\t\"}{range .spec.containers[*]}{.image}{\", \"}{end}{end}' | \\ sort 3. List Container images filtering by Pod label kubectl get pods --all-namespaces -o = jsonpath = \"{..image}\" -l app = nginx 4. List Container images filtering by Pod namespace kubectl get pods --namespace kube-system -o jsonpath = \"{..image}\" 5. List Container images using a go-template instead of jsonpath kubectl get pods --all-namespaces -o go-template --template = \"{{range .items}}{{range .spec.containers}}{{.image}} {{end}}{{end}}\" Other quick actions \u00b6 1. How to copy all secrets from one namespace to another? kubectl get secrets -o json --namespace namespace-old | \\ jq '.items[].metadata.namespace = \"namespace-new\"' | \\ kubectl create-f - 2. Quickly create a self-signed certificate for tests: openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj \"/CN=grafana.mysite.ru/O=MyOrganization\" kubectl -n myapp create secret tls selfsecret --key tls.key --cert tls.crt 3. Create job fron CronJob kubectl create job --from = cronjob/<cronjob-name> <job-name>","title":"Tips & Tricks"},{"location":"kubernetes/tipsandtricks/#get-list-of-pods-and-nodes","text":"1. Find all problem pods which not in Running state kubectl get pods -A --field-selector = status.phase! = Running | grep -v Complete Output ingress traefik-ingress-controller-77b6cbdf77-m724s 0/2 Evicted 0 42d ingress traefik-ingress-controller-77b6cbdf77-scsh5 0/2 Evicted 0 60d ingress traefik-ingress-controller-77b6cbdf77-vn5c9 0/2 Evicted 0 79d testing administration-v1-app-dd8699bb-znq6m 0/1 ImagePullBackOff 0 117m testing administration-v1-app-ffff66c9c-gs8pw 0/1 ImagePullBackOff 0 99m testing administration-v1-app-ffff66c9c-ngwjm 0/1 ImagePullBackOff 0 99m 2. Get list of nodes with ram capacity: kubectl get no -o json | \\ jq -r '.items | sort_by(.status.capacity.memory)[]|[.metadata.name,.status.capacity.memory]| @tsv' Output k8s-worker-system-01-dc14-fsn1 32171364Ki k8s-worker-system-01-dc3-nbg1 32171364Ki k8s-worker-system-02-dc14-fsn1 32171368Ki k8s-worker-system-02-dc3-nbg1 32171368Ki k8s-master-system-01-dc14-fsn1 7979256Ki k8s-master-system-01-dc3-nbg1 7979256Ki k8s-master-system-02-dc3-nbg1 7979264Ki 3. Get list of nodes with running pods on it: kubectl get po -o json --all-namespaces | \\ jq '.items | group_by(.spec.nodeName) | map({\"nodeName\": .[0].spec.nodeName, \"count\": length}) | sort_by(.count)' Output [ { \"nodeName\" : \"k8s-master-system-01-dc14-fsn1\" , \"count\" : 7 }, { \"nodeName\" : \"k8s-master-system-01-dc3-nbg1\" , \"count\" : 7 }, { \"nodeName\" : \"k8s-master-system-02-dc3-nbg1\" , \"count\" : 7 }, { \"nodeName\" : \"k8s-worker-system-01-dc3-nbg1\" , \"count\" : 14 }, { \"nodeName\" : \"k8s-worker-system-01-dc14-fsn1\" , \"count\" : 18 }, { \"nodeName\" : \"k8s-worker-system-02-dc14-fsn1\" , \"count\" : 18 }, { \"nodeName\" : \"k8s-worker-system-02-dc3-nbg1\" , \"count\" : 22 } ] 3. Script for list nodes which can not rollout DaemonSet ns = my-namespace pod_template = my-pod kubectl get node | grep -v \\\" $( kubectl -n ${ ns } get pod --all-namespaces -o wide | fgrep ${ pod_template } | awk '{print $8}' | xargs -n 1 echo -n \"\\|\" | sed 's/[[:space:]]*//g' ) \\\" 4. Get pod's that consume the maximum amount of cpu or memory: # cpu kubectl top pods -A | sort --reverse --key 3 --numeric # memory kubectl top pods -A | sort --reverse --key 4 --numeric","title":"Get list of pods and nodes"},{"location":"kubernetes/tipsandtricks/#get-other-information","text":"1. Debugging Ingress with wide output and finding labels: kubectl -n jaeger get svc -o wide Output NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTOR jaeger-cassandra ClusterIP None <none> 9042/TCP 77d app=cassandracluster,cassandracluster=jaeger-cassandra,cluster=jaeger-cassandra In this case, we immediately get a selector by which it finds the necessary pods. 2. Get limits and requests for each container of each pod: kubectl get pods -n my-namespace -o = custom-columns = 'NAME:spec.containers[*].name,MEMREQ:spec.containers[*].resources.requests.memory,MEMLIM:spec.containers[*].resources.limits.memory,CPUREQ:spec.containers[*].resources.requests.cpu,CPULIM:spec.containers[*].resources.limits.cpu' Output NAME MEMREQ MEMLIM CPUREQ CPULIM sentry-web 2Gi 2Gi 300m 700m sentry-web 2Gi 2Gi 300m 700m sentry-web 2Gi 2Gi 300m 700m sentry-web 2Gi 2Gi 300m 700m sentry-worker 1Gi 3Gi 300m 1 sentry-worker 1Gi 3Gi 300m 1 sentry-worker 1Gi 3Gi 300m 1 sentry-worker 1Gi 3Gi 300m 1 sentry-worker 1Gi 3Gi 300m 1 3. The kubectl run command (as well as create, apply, patch) has a wonderful ability to see changes before applying them - the --dry-run flag does this. And if used in conjunction with -o yaml , you can get the manifest of the required entity. For example: kubectl run test --image = grafana/grafana --dry-run -o yaml Output apiVersion : apps/v1 kind : Deployment metadata : creationTimestamp : null labels : run : test name : test spec : replicas : 1 selector : matchLabels : run : test strategy : {} template : metadata : creationTimestamp : null labels : run : test spec : containers : - image : grafana/grafana name : test resources : {} status : {} 4. Get an explanation on the manifest of a resource: kubectl explain hpa Output KIND: HorizontalPodAutoscaler VERSION: autoscaling/v1 DESCRIPTION: configuration of a horizontal pod autoscaler. FIELDS: apiVersion <string> APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources kind <string> Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds metadata <Object> Standard object metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata spec <Object> behaviour of autoscaler. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status. status <Object> current information about the autoscaler.","title":"Get other information"},{"location":"kubernetes/tipsandtricks/#networks","text":"1. Get internal IP addresses of cluster nodes: kubectl get nodes -o json | \\ jq -r '.items[].status.addresses[]? | select (.type == \"InternalIP\") | .address' | \\ paste -sd \"\\n\" - Output 49.12.46.61 159.69.86.119 159.69.30.239 168.119.52.4 159.69.158.121 168.119.50.31 116.203.153.163 2. List all services and the nodePort they occupy: kubectl get --all-namespaces svc -o json | \\ jq -r '.items[] | [.metadata.name,([.spec.ports[].nodePort | tostring ] | join(\"|\"))]| @tsv' Output nginx-ingress-controller 32244|32245 3 . In situations where there are problems with CNI, routes must be checked to identify the problem pod. This is where the pod subnets used in the cluster come in very handy: kubectl get nodes -o jsonpath = '{.items[*].spec.podCIDR}' | tr \" \" \"\\n\" Output 192.168.0.0/24 192.168.1.0/24 192.168.2.0/24 192.168.4.0/24 192.168.3.0/24 192.168.6.0/24 192.168.5.0/24","title":"Networks"},{"location":"kubernetes/tipsandtricks/#logs","text":"1. Getting pod logs with human readable timestamp in case of its absence kubectl -n my-namespace logs -f my-pod --timestamps Output 2020-07-08T14:01:59.581788788Z fail: Microsoft.EntityFrameworkCore.Query[10100] 2. Don't wait for the entire pod container log to be displayed - use --tail : kubectl -n my-namespace logs -f my-pod --tail = 50 3. Get logs from all pod containers: kubectl -n my-namespace logs -f my-pod --all-containers 4. Get logs from all pods based on the label: kubectl -n my-namespace logs -f -l app = nginx 5. Get the logs of the previous container, which, for example, fell: kubectl -n my-namespace logs my-pod --previous","title":"Logs"},{"location":"kubernetes/tipsandtricks/#list-all-container-images-running-in-a-cluster","text":"1. List all Container images in all namespaces kubectl get pods --all-namespaces -o jsonpath = \"{..image}\" | \\ tr -s '[[:space:]]' '\\n' | \\ sort | \\ uniq -c kubectl get pods --all-namespaces -o jsonpath = \"{.items[*].spec.containers[*].image}\" 2. List Container images by Pod kubectl get pods --all-namespaces -o = jsonpath = '{range .items[*]}{\"\\n\"}{.metadata.name}{\":\\t\"}{range .spec.containers[*]}{.image}{\", \"}{end}{end}' | \\ sort 3. List Container images filtering by Pod label kubectl get pods --all-namespaces -o = jsonpath = \"{..image}\" -l app = nginx 4. List Container images filtering by Pod namespace kubectl get pods --namespace kube-system -o jsonpath = \"{..image}\" 5. List Container images using a go-template instead of jsonpath kubectl get pods --all-namespaces -o go-template --template = \"{{range .items}}{{range .spec.containers}}{{.image}} {{end}}{{end}}\"","title":"List All Container Images Running in a Cluster"},{"location":"kubernetes/tipsandtricks/#other-quick-actions","text":"1. How to copy all secrets from one namespace to another? kubectl get secrets -o json --namespace namespace-old | \\ jq '.items[].metadata.namespace = \"namespace-new\"' | \\ kubectl create-f - 2. Quickly create a self-signed certificate for tests: openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj \"/CN=grafana.mysite.ru/O=MyOrganization\" kubectl -n myapp create secret tls selfsecret --key tls.key --cert tls.crt 3. Create job fron CronJob kubectl create job --from = cronjob/<cronjob-name> <job-name>","title":"Other quick actions"},{"location":"kubernetes/concepts/pod/","text":"Schema \u00b6 YAML Example \u00b6 apiVersion : v1 kind : Pod metadata : name : myapp-pod labels : app : myapp spec : containers : - name : myapp-container image : busybox command : [ 'sh' , '-c' , 'echo Hello Kubernetes! && sleep 3600' ]","title":"Pod"},{"location":"kubernetes/concepts/pod/#schema","text":"","title":"Schema"},{"location":"kubernetes/concepts/pod/#yaml-example","text":"apiVersion : v1 kind : Pod metadata : name : myapp-pod labels : app : myapp spec : containers : - name : myapp-container image : busybox command : [ 'sh' , '-c' , 'echo Hello Kubernetes! && sleep 3600' ]","title":"YAML Example"}]}